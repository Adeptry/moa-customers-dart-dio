//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//

import 'dart:async';

// ignore: unused_import
import 'dart:convert';
import 'package:myorderapp_square/src/deserialize.dart';
import 'package:dio/dio.dart';

import 'package:myorderapp_square/src/model/app_install_post_body.dart';
import 'package:myorderapp_square/src/model/customer_entity.dart';
import 'package:myorderapp_square/src/model/customer_patch_body.dart';
import 'package:myorderapp_square/src/model/customers_paginated_response.dart';

class CustomersApi {
  final Dio _dio;

  const CustomersApi(this._dio);

  /// Delete Customer with ID
  ///
  ///
  /// Parameters:
  /// * [id]
  /// * [xCustomLang]
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> deleteCustomerId({
    required String id,
    String? xCustomLang,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path =
        r'/v2/customers/{id}'.replaceAll('{' r'id' '}', id.toString());
    final _options = Options(
      method: r'DELETE',
      headers: <String, dynamic>{
        if (xCustomLang != null) r'x-custom-lang': xCustomLang,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'bearer',
            'name': 'bearer',
          },
          {
            'type': 'apiKey',
            'name': 'Api-Key',
            'keyName': 'Api-Key',
            'where': 'header',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    return _response;
  }

  /// Delete current Customer
  ///
  ///
  /// Parameters:
  /// * [merchantIdOrPath]
  /// * [xCustomLang]
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [CustomerEntity] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<CustomerEntity>> deleteCustomerMe({
    required String merchantIdOrPath,
    String? xCustomLang,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/v2/customers/me';
    final _options = Options(
      method: r'DELETE',
      headers: <String, dynamic>{
        if (xCustomLang != null) r'x-custom-lang': xCustomLang,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'bearer',
            'name': 'bearer',
          },
          {
            'type': 'apiKey',
            'name': 'Api-Key',
            'keyName': 'Api-Key',
            'where': 'header',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      r'merchantIdOrPath': merchantIdOrPath,
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    CustomerEntity? _responseData;

    try {
      final rawData = _response.data;
      _responseData = rawData == null
          ? null
          : deserialize<CustomerEntity, CustomerEntity>(
              rawData, 'CustomerEntity',
              growable: true);
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<CustomerEntity>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// Get current Customer
  ///
  ///
  /// Parameters:
  /// * [merchantIdOrPath]
  /// * [user]
  /// * [merchant]
  /// * [currentOrder]
  /// * [preferredLocation]
  /// * [preferredSquareCard]
  /// * [xCustomLang]
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [CustomerEntity] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<CustomerEntity>> getCustomerMe({
    required String merchantIdOrPath,
    bool? user,
    bool? merchant,
    bool? currentOrder,
    bool? preferredLocation,
    bool? preferredSquareCard,
    String? xCustomLang,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/v2/customers/me';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        if (xCustomLang != null) r'x-custom-lang': xCustomLang,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'bearer',
            'name': 'bearer',
          },
          {
            'type': 'apiKey',
            'name': 'Api-Key',
            'keyName': 'Api-Key',
            'where': 'header',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (user != null) r'user': user,
      if (merchant != null) r'merchant': merchant,
      if (currentOrder != null) r'currentOrder': currentOrder,
      if (preferredLocation != null) r'preferredLocation': preferredLocation,
      if (preferredSquareCard != null)
        r'preferredSquareCard': preferredSquareCard,
      r'merchantIdOrPath': merchantIdOrPath,
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    CustomerEntity? _responseData;

    try {
      final rawData = _response.data;
      _responseData = rawData == null
          ? null
          : deserialize<CustomerEntity, CustomerEntity>(
              rawData, 'CustomerEntity',
              growable: true);
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<CustomerEntity>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// Get my Customers
  ///
  ///
  /// Parameters:
  /// * [page]
  /// * [limit]
  /// * [user]
  /// * [merchant]
  /// * [currentOrder]
  /// * [preferredLocation]
  /// * [orderField]
  /// * [orderSort]
  /// * [startDate]
  /// * [endDate]
  /// * [xCustomLang]
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [CustomersPaginatedResponse] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<CustomersPaginatedResponse>> getCustomers({
    num? page,
    num? limit,
    bool? user,
    bool? merchant,
    bool? currentOrder,
    bool? preferredLocation,
    String? orderField,
    String? orderSort,
    String? startDate,
    String? endDate,
    String? xCustomLang,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/v2/customers';
    final _options = Options(
      method: r'GET',
      headers: <String, dynamic>{
        if (xCustomLang != null) r'x-custom-lang': xCustomLang,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'bearer',
            'name': 'bearer',
          },
          {
            'type': 'apiKey',
            'name': 'Api-Key',
            'keyName': 'Api-Key',
            'where': 'header',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (page != null) r'page': page,
      if (limit != null) r'limit': limit,
      if (user != null) r'user': user,
      if (merchant != null) r'merchant': merchant,
      if (currentOrder != null) r'currentOrder': currentOrder,
      if (preferredLocation != null) r'preferredLocation': preferredLocation,
      if (orderField != null) r'orderField': orderField,
      if (orderSort != null) r'orderSort': orderSort,
      if (startDate != null) r'startDate': startDate,
      if (endDate != null) r'endDate': endDate,
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    CustomersPaginatedResponse? _responseData;

    try {
      final rawData = _response.data;
      _responseData = rawData == null
          ? null
          : deserialize<CustomersPaginatedResponse, CustomersPaginatedResponse>(
              rawData, 'CustomersPaginatedResponse',
              growable: true);
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<CustomersPaginatedResponse>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// Update your Customer
  ///
  ///
  /// Parameters:
  /// * [merchantIdOrPath]
  /// * [customerPatchBody]
  /// * [user]
  /// * [merchant]
  /// * [currentOrder]
  /// * [preferredLocation]
  /// * [preferredSquareCard]
  /// * [xCustomLang]
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [CustomerEntity] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<CustomerEntity>> patchCustomerMe({
    required String merchantIdOrPath,
    required CustomerPatchBody customerPatchBody,
    bool? user,
    bool? merchant,
    bool? currentOrder,
    bool? preferredLocation,
    bool? preferredSquareCard,
    String? xCustomLang,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/v2/customers/me';
    final _options = Options(
      method: r'PATCH',
      headers: <String, dynamic>{
        if (xCustomLang != null) r'x-custom-lang': xCustomLang,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'bearer',
            'name': 'bearer',
          },
          {
            'type': 'apiKey',
            'name': 'Api-Key',
            'keyName': 'Api-Key',
            'where': 'header',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      if (user != null) r'user': user,
      if (merchant != null) r'merchant': merchant,
      if (currentOrder != null) r'currentOrder': currentOrder,
      if (preferredLocation != null) r'preferredLocation': preferredLocation,
      if (preferredSquareCard != null)
        r'preferredSquareCard': preferredSquareCard,
      r'merchantIdOrPath': merchantIdOrPath,
    };

    dynamic _bodyData;

    try {
      _bodyData = jsonEncode(customerPatchBody);
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _options.compose(
          _dio.options,
          _path,
          queryParameters: _queryParameters,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    CustomerEntity? _responseData;

    try {
      final rawData = _response.data;
      _responseData = rawData == null
          ? null
          : deserialize<CustomerEntity, CustomerEntity>(
              rawData, 'CustomerEntity',
              growable: true);
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<CustomerEntity>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// Create Customer for current User
  ///
  ///
  /// Parameters:
  /// * [merchantIdOrPath]
  /// * [user]
  /// * [merchant]
  /// * [currentOrder]
  /// * [preferredLocation]
  /// * [xCustomLang]
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future] containing a [Response] with a [CustomerEntity] as data
  /// Throws [DioException] if API call or serialization fails
  Future<Response<CustomerEntity>> postCustomerMe({
    required String merchantIdOrPath,
    bool? user,
    bool? merchant,
    bool? currentOrder,
    bool? preferredLocation,
    String? xCustomLang,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/v2/customers/me';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (xCustomLang != null) r'x-custom-lang': xCustomLang,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'bearer',
            'name': 'bearer',
          },
          {
            'type': 'apiKey',
            'name': 'Api-Key',
            'keyName': 'Api-Key',
            'where': 'header',
          },
        ],
        ...?extra,
      },
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      r'merchantIdOrPath': merchantIdOrPath,
      if (user != null) r'user': user,
      if (merchant != null) r'merchant': merchant,
      if (currentOrder != null) r'currentOrder': currentOrder,
      if (preferredLocation != null) r'preferredLocation': preferredLocation,
    };

    final _response = await _dio.request<Object>(
      _path,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    CustomerEntity? _responseData;

    try {
      final rawData = _response.data;
      _responseData = rawData == null
          ? null
          : deserialize<CustomerEntity, CustomerEntity>(
              rawData, 'CustomerEntity',
              growable: true);
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _response.requestOptions,
        response: _response,
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    return Response<CustomerEntity>(
      data: _responseData,
      headers: _response.headers,
      isRedirect: _response.isRedirect,
      requestOptions: _response.requestOptions,
      redirects: _response.redirects,
      statusCode: _response.statusCode,
      statusMessage: _response.statusMessage,
      extra: _response.extra,
    );
  }

  /// Create or update Customer App Install
  ///
  ///
  /// Parameters:
  /// * [merchantIdOrPath]
  /// * [appInstallPostBody]
  /// * [xCustomLang]
  /// * [cancelToken] - A [CancelToken] that can be used to cancel the operation
  /// * [headers] - Can be used to add additional headers to the request
  /// * [extras] - Can be used to add flags to the request
  /// * [validateStatus] - A [ValidateStatus] callback that can be used to determine request success based on the HTTP status of the response
  /// * [onSendProgress] - A [ProgressCallback] that can be used to get the send progress
  /// * [onReceiveProgress] - A [ProgressCallback] that can be used to get the receive progress
  ///
  /// Returns a [Future]
  /// Throws [DioException] if API call or serialization fails
  Future<Response<void>> updateAppInstallMe({
    required String merchantIdOrPath,
    required AppInstallPostBody appInstallPostBody,
    String? xCustomLang,
    CancelToken? cancelToken,
    Map<String, dynamic>? headers,
    Map<String, dynamic>? extra,
    ValidateStatus? validateStatus,
    ProgressCallback? onSendProgress,
    ProgressCallback? onReceiveProgress,
  }) async {
    final _path = r'/v2/customers/me/app-install';
    final _options = Options(
      method: r'POST',
      headers: <String, dynamic>{
        if (xCustomLang != null) r'x-custom-lang': xCustomLang,
        ...?headers,
      },
      extra: <String, dynamic>{
        'secure': <Map<String, String>>[
          {
            'type': 'http',
            'scheme': 'bearer',
            'name': 'bearer',
          },
          {
            'type': 'apiKey',
            'name': 'Api-Key',
            'keyName': 'Api-Key',
            'where': 'header',
          },
        ],
        ...?extra,
      },
      contentType: 'application/json',
      validateStatus: validateStatus,
    );

    final _queryParameters = <String, dynamic>{
      r'merchantIdOrPath': merchantIdOrPath,
    };

    dynamic _bodyData;

    try {
      _bodyData = jsonEncode(appInstallPostBody);
    } catch (error, stackTrace) {
      throw DioException(
        requestOptions: _options.compose(
          _dio.options,
          _path,
          queryParameters: _queryParameters,
        ),
        type: DioExceptionType.unknown,
        error: error,
        stackTrace: stackTrace,
      );
    }

    final _response = await _dio.request<Object>(
      _path,
      data: _bodyData,
      options: _options,
      queryParameters: _queryParameters,
      cancelToken: cancelToken,
      onSendProgress: onSendProgress,
      onReceiveProgress: onReceiveProgress,
    );

    return _response;
  }
}
